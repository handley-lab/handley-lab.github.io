from google import genai
import requests
import os
import feedparser
from pandas import to_datetime
from io import BytesIO
import tarfile
import sys

arxiv = sys.argv[1]
arxiv = '2410.16030'


basic_model = "gemini-1.5-flash"
text_model = "gemini-1.5-pro"
image_model = "gemini-2.0-flash-exp-image-generation"
url_model = "https://deepmind.google/technologies/gemini/"

# Get arxiv metadata
url = f"https://export.arxiv.org/api/query?id_list={arxiv}"
response = requests.get(url)
response.raise_for_status()
feed = feedparser.parse(response.content)
metadata = feed.entries[0]
metadata.published
dt = to_datetime(feed.entries[0].published)

# Get arxiv source
response = requests.get(f'https://arxiv.org/src/{arxiv}')
tar_stream = BytesIO(response.content)
tex = ''
bbl = ''
with tarfile.open(fileobj=tar_stream, mode='r') as tar:
    for member in tar.getmembers():
        file = tar.extractfile(member)
        if member.name.endswith('.tex'):
            tex += file.read().decode('utf-8')
        if member.name.endswith('.bbl'):
            bbl += file.read().decode('utf-8')

# Read group yaml file:
import yaml
with open('assets/group/group.yaml', 'r') as f:
    group = f.read()
    group = yaml.safe_load(group)

with open('index.md', 'r') as f:
    homepage = f.read()

client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

contents = f"""
Find the dictionary keys in the following group:
```python
{group.keys()}
```
that most closely match the following authors:
```python
{metadata.authors}
```
Give your answer as comma separate list of keys, in the same order as the authors list. If you cannot find a match, just list the original author name.
"""

response = client.models.generate_content(model=basic_model, contents=contents)
authors = response.text.split(',')
authors = {author.strip():group.get(author.strip(), author.strip()) for author in authors}
images = ''.join([f"<img src=\"/assets/group/{dat['image']}\" alt=\"{a}\" style=\"width: 25%; height: auto;\">" for a, dat in authors.items() if'image' in dat])

postname = f'{dt.strftime("%Y-%m-%d")}-{arxiv}'
imagename = f'/assets/images/posts/{postname}.png'
prompt_save = f'/prompts/posts/{postname}.md'
image_prompt_save = f'/prompts/images/{postname}.md'


prompt = f"""
I’m creating a new blog post for our research website that integrates details about our work and features a research paper. You must generate a final Markdown file (ready for a GitHub-served Jekyll site) that exactly follows the output format below.

Output Format (Markdown):
-------------------------------------------------
---
layout: post
title:  {metadata.title}
date:   {dt.strftime('%Y-%m-%d')}
categories: papers
---
![AI generate image from the prompt]({imagename})\\
<!-- BEGINNING OF GENERATED POST -->

<!-- END OF GENERATED POST -->\\
{images}\\
Post generated by [{text_model}]({url_model}) using [this prompt]({prompt_save}).\\
Image generated by [{image_model}]({url_model}) using [this prompt]({image_prompt_save}).\\
-------------------------------------------------

Instructions for Generating the Page Body:
1. Write a well-composed, engaging page body that is suitable for a scholarly audience interested in advanced AI and astrophysics.
2. Use the tone and style inspired by our homepage (see the “Homepage Content” block), but do not directly reuse its content.
3. Highlight key aspects of the paper using details from the Paper Metadata (JSON) and the Paper Source (TeX). Emphasize the contributions and the impact of the work, with special focus on the lead author ({metadata.authors[0]}). When mentioning the authors, use any links provided in the Author Information block.
4. Contextualize the research within the broader literature by leveraging the Bibliographic Information (bbl block) to generate Markdown-formatted links (using DOIs or arXiv numbers).
   - Review the Bibliographic Information (bbl block) and extract every reference that includes a DOI or arXiv identifier.
   - For each such entry, generate a Markdown link formatted as:
     - DOI Example: [DOI:10.1234/xyz](https://doi.org/10.1234/xyz)
     - arXiv Example: [arXiv:2103.12345](https://arxiv.org/abs/2103.12345)
   - Ensure that three or more of the most relevant literature links are seamlessly integrated into the narrative.
5. Seamlessly integrate information from all provided materials (metadata, TeX source, bbl file, and author information) to form a cohesive and informative narrative.
6. Ensure that the final output is plain Markdown—do not wrap the output in a Markdown code block.

Data Provided:
1. Homepage Content (for tone and context):
```markdown
{homepage}
```

2. Paper Metadata (essential details about the research paper):
```json
{metadata}
```

3. Paper Source (raw TeX content of the paper):
```tex
{tex}
```

4. Bibliographic Information (bibliography details for generating links):
```bbl
{bbl}
```

5. Author Information:
- Lead Author: {metadata.authors[0]}
- Full Authors List:
```json
{authors}
```

Generate only the final Markdown output based on the format above.

Double-check that each bibliographic reference with a DOI or arXiv is used to generate a Markdown link.
"""


print("Generating post")
response = client.models.generate_content(model=text_model, contents=prompt)
post = response.text
print("Post generated")


pre_image_prompt=f"""
Generate a prompt which will generate an image to headline this post:
```markdown
{post}
```
"""
response = client.models.generate_content(model=text_model, contents=pre_image_prompt)
image_prompt = response.text

print("Generating image")
response = client.models.generate_content(model=image_model, contents=image_prompt, config=genai.types.GenerateContentConfig( response_modalities=['Text', 'Image']))
print("Image generated")

from PIL import Image
image = Image.open(BytesIO(
    response.candidates[0].content.parts[0].inline_data.data
    ))

# Save image
image.save(f'.{imagename}')

# Save post
with open(f'_posts/{postname}.md', 'w') as f:
    f.write(post)

# Save prompts
with open(f'.{prompt_save}', 'w') as f:
    f.write(prompt)

with open(f'.{image_prompt_save}', 'w') as f:
    f.write(image_prompt)
